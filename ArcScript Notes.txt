================================================================================
                    ArcScript: Development Journey & Notes
================================================================================

This document explains how I built ArcScript from scratch, the decisions I made,
and what I learned along the way. Written for technical discussions, interviews,
and anyone curious about the process.


WHY I BUILT THIS
-----------------

I wanted to create a scripting language specifically designed for game logic.
Most existing options felt either too complex (Python with its verbosity) or
too minimal (Lua lacking modern features). I wanted something that:

  - Feels natural to write when implementing game mechanics
  - Has proper closures for AI behaviors and event handlers
  - Includes built-in math and string functions game developers actually need
  - Provides helpful error messages instead of cryptic failures
  - Runs fast enough for real-time game loops

The goal wasn't to compete with established languages, but to explore language
design and build something practical that demonstrates my understanding of
compilers, interpreters, and software architecture.


TECHNICAL ARCHITECTURE
-----------------------

I implemented ArcScript as a tree-walking interpreter in Rust. Here's why:

Why Rust?
  - Memory safety without garbage collection (important for game engines)
  - Strong type system catches bugs at compile time
  - Performance comparable to C/C++
  - Modern tooling (cargo, clippy, great error messages)

Why Tree-Walking Instead of Bytecode?
  - Simpler to implement and debug
  - Easier to understand for educational purposes
  - Good enough performance for the MVP
  - Bytecode VM can be added later as an optimization

The pipeline is straightforward:
  Source Code → Lexer → Tokens → Parser → AST → Interpreter → Execution

Each stage has a single responsibility, making the codebase maintainable.


LEXER (src/lexer.rs)
--------------------

The lexer breaks source text into tokens. I implemented it as a character-by-
character scanner with look-ahead for multi-character operators.

Key Decisions:
  - Support for compound operators (+=, -=, etc.) recognized during lexing
  - Both // and /* */ comment styles
  - Proper string escape sequence handling
  - Line and column tracking for error messages

Challenges:
  - Initially forgot to handle \n and \r properly for Windows/Unix compatibility
  - Had to add look-ahead for distinguishing = from ==, ! from !=, etc.


PARSER (src/parser.rs)
----------------------

Recursive descent parser with operator precedence. I chose this approach because:
  - Easy to understand and maintain
  - Direct mapping from grammar to code
  - Good error recovery opportunities

Key Features:
  - Pratt parsing for expression precedence
  - Error recovery that continues parsing to report multiple errors
  - Compound assignments desugared at parse time (x += 5 becomes x = x + 5)

The precedence hierarchy:
  assignment → or → and → equality → comparison → term → factor → unary → primary

This naturally handles operator precedence without a separate table.

Challenges:
  - Getting operator precedence right took iteration
  - Error recovery without infinite loops required careful token consumption
  - Desugaring compound assignments cleanly while preserving line numbers


AST (src/ast.rs)
----------------

Clean enum-based representation of the syntax tree. I kept it simple with clear
variants for each language construct.

Design Choices:
  - Separate types for expressions (Expr) and statements (Stmt)
  - Binary operators as their own enum for type safety
  - Function declarations store parameters and body directly
  - No separate "program" node, just a vector of statements

This makes pattern matching in the interpreter clean and exhaustive.


INTERPRETER (src/interpreter.rs)
--------------------------------

Tree-walking interpreter with environment-based scoping. This is where most of
the complexity lives.

Environment Model:
  - Chain of hashmaps for nested scopes
  - Each function call creates a new environment linked to the closure
  - Variable lookup walks the chain upward

Value System:
  I implemented a simple enum for runtime values:
    - Int, Float (with automatic promotion in mixed operations)
    - Bool, String
    - Function (stores declaration + closure environment)
    - Table (HashMap for key-value data)
    - Nil (represents absence of value)

Closure Implementation:
  Functions capture their defining environment, not just specific variables.
  This is simpler than per-variable capture analysis and handles nested
  closures correctly.

Built-in Functions:
  Implemented 19 built-ins covering:
    - I/O: print, println
    - Type operations: type, len
    - Conversions: str, int, float
    - Math: abs, min, max, floor, ceil, round, sqrt, pow
    - Strings: substring, contains, toUpper, toLower

  These are registered as special Function values with a "builtin" tag.

Challenges:
  - Handling return statements required propagating a Result type
  - Break/continue in loops needed careful control flow handling
  - Type coercion between Int and Float required consistent rules
  - Zero-division checks for both / and % operators


FEATURES I'M PROUD OF
----------------------

For Loops with Step:
  Syntax: for i = start, end, step do { ... } end

  This supports forward and backward iteration naturally. The step can be
  negative for countdown loops. I evaluate all three expressions once at
  loop entry, then use simple arithmetic to control iteration.

Compound Assignments:
  x += 5 desugars to x = x + 5 at parse time. This avoids duplicating
  assignment logic in the interpreter while still providing the convenience.

Error Messages:
  I track line numbers through the pipeline and include them in runtime
  errors. Parse errors show line, column, and what was expected vs found.

Tables:
  Implemented as HashMap<String, Value> with both dot and bracket notation.
  This makes them flexible for game state, entity properties, etc.


TESTING STRATEGY
----------------

I wrote unit tests for:
  - Arithmetic operations and type coercion
  - Variable scoping and shadowing
  - Function calls and closures
  - Control flow (if/elif/else, loops, break/continue)
  - Built-in functions
  - Error cases (undefined variables, type errors, etc.)

I also created 10 example scripts demonstrating every feature, which serve
as integration tests and documentation.


WHAT I LEARNED
---------------

Language Design is Full of Trade-offs:
  - Simple syntax vs expressive power
  - Performance vs ease of implementation
  - Static vs dynamic typing
  - Implicit vs explicit conversions

Every decision affects usability and implementation complexity. I had to
prioritize what matters for the target use case (game scripting).

Error Handling is Crucial:
  Good error messages make or break the user experience. I spent significant
  time on parse error recovery and helpful runtime error messages.

Documentation Matters:
  Writing the README and Guide forced me to clarify design decisions and
  think about the user's mental model of the language.

Rust's Type System is Powerful:
  Exhaustive pattern matching caught bugs early. The borrow checker prevented
  memory safety issues I would have hit in C/C++.


WHAT I'D DO DIFFERENTLY
------------------------

If I were starting over or building v2.0:

1. Bytecode VM from the Start
   Tree-walking is slow for tight loops. A stack-based VM would be 10-50x
   faster and would teach me more about runtime optimization.

2. Static Analysis Pass
   Catching undefined variables, type errors, and unreachable code before
   runtime would improve the developer experience significantly.

3. LSP Integration
   A language server would provide IDE support (autocomplete, go-to-definition,
   inline errors). This is a huge quality-of-life improvement.

4. Module System
   Right now, everything is in one file. A proper import/export system would
   enable code reuse and better organization.

5. More Built-in Data Structures
   Arrays with indexing, sets, and maybe vectors for game math would make
   the language more practical.


TECHNICAL METRICS
-----------------

Final Statistics:
  - ~2,500 lines of Rust code
  - 19 built-in functions
  - 10+ unit tests
  - 10 example scripts
  - Full EBNF grammar specification
  - Complete documentation (README + Guide)

Development Time:
  - Core implementation (lexer, parser, interpreter): ~40 hours
  - Features (for loops, built-ins, operators): ~20 hours
  - Testing and examples: ~10 hours
  - Documentation: ~15 hours
  - Total: ~85 hours over 2 weeks


SKILLS DEMONSTRATED
-------------------

Through this project, I've demonstrated:

Programming Languages:
  - Understanding of lexical analysis and tokenization
  - Parser design and implementation (recursive descent, operator precedence)
  - AST design and traversal
  - Runtime environment and scoping rules
  - Closure implementation
  - Type systems and coercion

Software Engineering:
  - Clean code architecture with separation of concerns
  - Comprehensive testing strategy
  - Documentation for technical and non-technical audiences
  - Version control with clear commit history
  - Project structure and organization

Problem Solving:
  - Trade-off analysis in language design
  - Debugging complex interactions (closures, scoping, control flow)
  - Error recovery in parsers
  - Performance considerations

Rust Expertise:
  - Idiomatic Rust (enums, pattern matching, Result/Option types)
  - Ownership and borrowing
  - Trait implementations
  - Cargo project setup


FUTURE ROADMAP
--------------

If I continue developing ArcScript:

Short-term (v1.1):
  - Bytecode compiler and VM
  - Basic optimization passes (constant folding, dead code elimination)
  - Better error messages with suggestions

Medium-term (v1.5):
  - Event system for game lifecycle hooks
  - Standard library for game math (vectors, matrices)
  - FFI for calling C/Rust code
  - VSCode extension with syntax highlighting

Long-term (v2.0):
  - LSP server for IDE support
  - Debugger with breakpoints and step-through
  - Module system and package manager
  - JIT compilation for hot functions


WHY THIS MATTERS FOR GAME DEVELOPMENT
--------------------------------------

Game scripting needs:
  - Fast iteration (no compile step)
  - Safe execution (can't crash the engine)
  - Easy for designers to learn and use
  - Good performance for AI and gameplay logic

ArcScript addresses these by providing:
  - Interpreted execution with REPL for quick testing
  - Rust's safety guarantees carry over to the embedded interpreter
  - Clean syntax inspired by popular languages
  - Foundation for future optimization (bytecode, JIT)


CONCLUSION
----------

Building ArcScript taught me more about language implementation than any
course could. The experience of making design decisions, implementing them,
and living with the consequences gave me deep insight into how languages work.

The project demonstrates that I can:
  - Take an idea from concept to working implementation
  - Make principled technical decisions and explain the trade-offs
  - Write clean, maintainable code in a systems language
  - Document my work for different audiences
  - Test thoroughly and iterate based on feedback

Most importantly, it shows I'm genuinely interested in how things work at a
fundamental level, not just using tools but understanding and building them.


================================================================================

For questions or discussion about this project:
- Read the full code in src/
- Try the examples in examples/
- Check out the language guide in docs/ArcScript_Guide.txt

This document is meant to be shared during interviews or technical discussions
to provide context about the project's development and my thought process.

================================================================================
